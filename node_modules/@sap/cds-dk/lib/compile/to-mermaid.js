const cds = require('../cds')

module.exports = function to_mermaid (model, options={}) {
  options = Object.assign({
    assocnames: false,     // include association names
    elements  : false,     // include all elements { falsy | 'all'|true | 'keys' }
    min       : false,     // minify the model, i.e. remove unused definitions, available in CLI
    namespaces: true,      // group entities by namespace/service
    queries   : false,     // include relations for queries
    service   : undefined, // filter service by name, available in CLI
    direction : undefined  // direction of the graph
  }, cds.env.mermaid ?? {}, options)

  const elemOpts = options.elements === 'none' ? false : options.elements
  if (options.min)  model = cds.minify(model)

  model = cds.linked(model)
  const allServices = model.all('service')

  // filter by one service if its name is given or only one service is present
  const srvFilter = options.service ?? (Object.keys(allServices).length === 1 ? allServices[0].name : undefined)
  if (srvFilter && !model.definitions[srvFilter]) {
    throw new Error(`Service "${srvFilter}" not found among ${model.all('service').map(s => s.name).sort()}`)
  }

  const seenEntities = new Set()
  const namespaces = {}
  const entityFilter = e => !e.name.startsWith('cds.') && !e.name.endsWith('.texts')

  let diag = ''
  const direction = options.direction ? `  direction ${options.direction}\n` : ''

  // if requested, filter by one service
  model.all('service')
  .filter (srv => !srvFilter || srv.name === srvFilter)
  .forEach(srv => {
    namespaces[srv.name] = []
    for (let e of model.entities(srv)) if (entityFilter(e)) {
      namespaces[srv.name].push(e)
      seenEntities.add(e.name)
    }
  })

  // group other namespaces/services
  if (options.namespaces) {
    model.all('entity')
    .filter (e => !seenEntities.has(e.name))
    .filter (entityFilter)
    .forEach (e => {
      const ns = e.name.slice(0,e.name.lastIndexOf('.'))
      if (!srvFilter || ns === srvFilter) {
        namespaces[ns] = namespaces[ns] || []
        namespaces[ns].push(e)
        seenEntities.add(e.name)
      }
    })

    // create namespace groups and classes
    Object.keys(namespaces)
    .filter (ns => namespaces[ns].length) // empty namespaces can cause rendering errors, so skip them
    .forEach(ns => {
      if (!diag.length)  diag = `classDiagram\n${direction}`
      diag += `  namespace ${ns.replaceAll('.','_')} {\n`
      namespaces[ns].forEach (e => {
        const simpleName = e.name.slice(e.name.lastIndexOf('.')+1)
        diag += `    class \`${e.name}\``
        diag += `["${simpleName}"]` // simple name as label
        if (elemOpts) {
          diag += ` {\n`
          if (e.elements) [...e.elements].forEach (el => {
            if ((elemOpts === 'all' || elemOpts === true) || (el.key && elemOpts == 'keys')) {
              diag += `      +${el._type?.replace('cds.','')} ${el.name}`
              diag += `\n`
            }
          })
          diag += `    }`
        }
        diag += `\n`
      })
      diag += `  }\n`
    })
    diag += `\n`
  }

  // add associations, either from collected entities or all entities
  const entities = seenEntities.size
    ? Array.from(seenEntities).map(name => model.definitions[name])
    : model.all('entity').filter (entityFilter) // if no grouping and no service filter is on
  entities.forEach(e => {
    if (!diag.length)  diag = `classDiagram\n${direction}`
    if (e.elements) [...e.elements].forEach (el => {
      if (el instanceof cds.Association) {
        if (el.target.endsWith('.texts'))  return
        const type = el.type === 'cds.Composition' ? '*-->' : '-->'
        const card = el.cardinality?.max === '*' ? '"*"' : ''
        diag += `  \`${e.name}\` ${type} ${card} \`${el.target}\``
        if (options.assocnames) {
          diag += `: ${el.name}`
        }
        diag += `\n`
      }
    })
    // add relations for queries
    if (e.query && options.queries)  {
      resolveTargets(e.query).forEach(t => {
        diag += `  \`${e.name}\` ..> \`${t}\`\n`
      })
    }
  })

  return diag.trim()
}

function resolveTargets (query) {
  if (query.target)  return [ query.target.name ] // simple query, like projection on

  // SELECT: { from: { args: [{ ref: ['t1'] }, { ref: ['t2'] }], join: ..., on: ... } }
  const targets = query.SELECT?.from?.args?.filter(arg => arg.ref?.length).map (arg => arg.ref[0])

  return targets
}
