const cds = require('@sap/cds')
const LOG = cds.log('mtx')
const { promisify } = require('util')

const getCompilerError = messages => {
  const defaultMsg = 'Error while compiling extension'
  if (!messages) return defaultMsg

  for (const msg of messages) {
    if (msg.severity === 'Error') return msg.message
  }

  return defaultMsg
}

// REVISIT: opt-in/out retry mechanism on runtime layer?
// Sketch: cds.tx({ tenant: 't1', retries: 2 }, ...)
// Not for all error cases a retry is an appropriate handling mechanism (e.g. 403)
// -> error code allow/blocklist

/**
 * @template T
 * @param {() => Promise<T>} fn
 * @param {number} [retryCount=5]
 * @param {number} [initialRetryGap=5000]
 * @returns {Promise<T>}
 */
const retry = async (fn, retryCount = cds.requires.multitenancy?.retries ?? 10, initialRetryGap = 5000) => {
  let errorCount = 0
  let finalError
  let retryGap = initialRetryGap
  while (errorCount < retryCount - 1) {
    try {
      return await fn()
    } catch (error) {
      if (error.code === 400) throw error
      if (error.code === 'SQLITE_ERROR') throw error // REVISIT: ugly -> shouldn't have to code for specific DBs
      finalError = error
      errorCount++
      LOG.error('attempt', errorCount, 'errored with', error, '- retrying attempt', errorCount + 1, 'of', retryCount)
      await promisify(setTimeout)(retryGap)
      retryGap *= 1.5
    }
  }
  LOG.error(`exceeded maximum number of ${retryCount} retries`)
  throw finalError
}

const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
let _t0Csn
const t0_ = async (query) => retry(async () => {
  _t0Csn ??= cds.compile.for.nodejs(
    await cds.load(`${__dirname}/../db/t0.cds`, { silent: true })
  )
  return cds.tx({ tenant: t0 }, tx => { tx.model = _t0Csn; return tx.run(query) })
})

module.exports = {
  getCompilerError,
  t0_,
  retry,
}
