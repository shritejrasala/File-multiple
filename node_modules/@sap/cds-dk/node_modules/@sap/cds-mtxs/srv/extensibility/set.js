const cds = require('@sap/cds/lib')
const { activate: activateExt} = require('./activate')

const _isCSN = str => str.substring(0, 1) === '{'

const _validateInput = function (req, extension) {
  // if (!req.user.is('internal-user') && req.data.tenant && req.data.tenant !== req.tenant)
  //   req.reject(403, `No permission to add extensions to tenants other than ${req.tenant}`)

  if (!extension) throw new cds.error ({ message: 'Property "extension" is missing', code: 400 })

  if (Array.isArray(extension)) {
    if (!extension.length) throw new cds.error ({ message: 'Property "extension" is empty', code: 400 })
  } else {
    const length = typeof extension === 'string' ? extension.length : Object.keys(extension).length
    if (!length) throw new cds.error ({ message: 'Property "extension" is malformed', code: 400 })
  }
}

const _mergeCSN = function (extension, merged) {
  if (!merged) merged = { extensions: [], definitions: {} }
  if (extension.definitions) Object.assign (merged.definitions, extension.definitions)
  if (extension.extensions) merged.extensions.push (...extension.extensions)

  return merged
}

const _toJson = function (content) {
  const json = {}
  const splitted = content.split('\n')
  splitted.forEach(s => {
    const parts = s.split('=')
    if (parts.length === 2) {
      json[parts[0].trim()] = parts[1].trim()
    }
  })

  return json
}

const _getFiles = function (resources) {
  let bundles = {}
  let fromJson = false
  const csvs = {}
  if (resources && Array.isArray(resources) && resources.length) {
    resources.forEach(file => {
      let key = file.name.match(/i18n_*(.*)\.properties/)
      if (key) {
        if (fromJson) throw new cds.error ({ message:  `Mixed i18n file types not supported: i18n.json and ${file.name}`, code: 422 })
        bundles[key[1]] = _toJson(file.content)
        return
      }
      key = file.name.match(/i18n.json/)
      if (key) {
        if (Object.entries(bundles).length) throw new cds.error ({ message:`Mixed i18n file types not supported: i18n.json and .properties`, code: 422 })
        try {
          bundles = JSON.parse(file.content)
          fromJson = true
        } catch (e) {
          throw new cds.error ({ message: `Invalid json content in i18n.json: ${e.message}`, code: 422 })
        }
        return
      }
      key = file.name.match(/.*\.csv/)
      if (key) {
        csvs[file.name] = file.content
      }
    })
  }

  return { bundles, csvs }
}

const  setExtension = async function(req) {
  let { extension, tag, resources, activate } = req.data
  const tenant = (req.user.is('internal-user') && req.data.tenant) || req.tenant || '' // revisit magic
  return set_(req, { extension, tag, resources, activate, tenant })
}

const set_ = async function (req, { extension, tag, resources, activate, tenant }) {
  _validateInput(undefined, extension)

  if (tenant) cds.context = { tenant }

  if (!activate) activate = 'database'
  if (!tag) tag = null

  let extCsn
  for (let ext of extension) {
    if (typeof ext === 'string') {
      if (!ext.length) throw new cds.error ({ message: 'Missing extension', code: 400 })
      if (_isCSN(ext)) extCsn = _mergeCSN(JSON.parse(ext), extCsn)
      else try { extCsn = _mergeCSN(cds.parse.cdl(ext), extCsn) } catch (e) {
        if (e.code === 'ERR_CDS_COMPILATION_FAILURE') throw new cds.error ({ message: e.message, code: 422 })
        else throw e
      }
    } else {
      if (!Object.keys(ext).length) throw new cds.error ({ message: 'Missing extension', code: 400 })
      extCsn = _mergeCSN(ext, extCsn)
    }
  }
  if (extCsn.requires) delete extCsn.requires

  const { bundles, csvs } = _getFiles(resources)

  await activateExt(tenant, tag, extCsn, bundles, csvs, null, activate, req)
}

module.exports = { set_, setExtension }
